import numpy as np
import pandas as pd
import sqlite3
import os
import datetime
import re
import ast
import glob
import streamlit as st
from dotenv import load_dotenv
from langchain.agents import create_sql_agent
from langchain.agents.agent_toolkits import SQLDatabaseToolkit
from langchain.sql_database import SQLDatabase
from langchain.llms.openai import OpenAI
from langchain.agents import AgentExecutor
from langchain.agents.agent_types import AgentType
from langchain.chat_models import ChatOpenAI
from htmlTemplates import css, bot_template, user_template
from description import *

# Supported file formats and their corresponding read functions
file_formats = {
    "csv": pd.read_csv,
    "xls": pd.read_excel,
    "xlsx": pd.read_excel,
    "xlsm": pd.read_excel,
    "xlsb": pd.read_excel,
}

def is_valid_path(path):
    """
    Check if a given path exists.

    Parameters:
    - path (str): The path to check for existence.

    Returns:
    - bool: True if the path exists, False otherwise.
    """
    return os.path.exists(path)

def reset_session_state():
    """
    Reset session state variables to their initial values.
    """
    st.session_state.dataBase = None
    st.session_state.table_names = None
    st.session_state.table_schemas = None

def load_data(uploaded_files):
    """
    Load data from uploaded files.

    Parameters:
    - uploaded_files (list): A list of uploaded file objects.

    Returns:
    - list: A list of data frames created from the uploaded files.
    """
    df_list = []
    for file in uploaded_files:
        try:
            ext = os.path.splitext(file.name)[1][1:].lower()
        except:
            ext = file.split(".")[-1]
        if ext in file_formats:
            df_list.append(file_formats[ext](file))
        else:
            st.error(f"Unsupported file format: {ext}")
            return None
    return df_list

def process_dataframes_to_sql(Database, table_names, table_schemas, df_list):
    """
    Process and save data frames to a SQLite database.

    Parameters:
    - Database (str): The name of the database where tables will be saved.
    - table_names (list): A list of table names to create.
    - table_schemas (list): A list of table schemas as dictionaries.
    - df_list (list): A list of data frames to save.

    Note:
    The function assumes that the database is located in the same directory as the app.py file and has a .sqlite extension.
    """
    connection = sqlite3.connect(f'{Database}.sqlite')
    cursor = connection.cursor()

    # Process each table one by one
    for idx, table_name in enumerate(table_names):
        df = df_list[idx]

        # Create table schema based on user input
        table_schema = ", ".join([f"{key.replace(' ', '_')} {value}" for key, value in table_schemas[idx].items()])
        create_table_sql = f"CREATE TABLE IF NOT EXISTS {table_name} ({table_schema})"

        # Execute table creation and save data to the table
        cursor.execute(create_table_sql)
        connection.commit()
        df.to_sql(table_name, connection, if_exists='replace', index=False)
        del df

    cursor.close()
    connection.close()

def execute_sql_query(query):
    """
    Execute SQL queries using Langchain and SQLDatabase.

    Parameters:
    - query (str): The SQL query to execute.

    Returns:
    - str: The response generated by the SQL execution.
    """
    db = SQLDatabase.from_uri(f'sqlite:///{st.session_state.dataBase}.sqlite')
    toolkit = SQLDatabaseToolkit(db=db, llm=OpenAI(temperature=0))
    agent_executor = create_sql_agent(
        llm=OpenAI(temperature=0),
        toolkit=toolkit,
        verbose=True,
        agent_type=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
        return_intermediate_steps=True
    )
    return agent_executor.run(query)

def get_available_databases():
    """
    Get a list of available databases in the current directory.

    Returns:
    - tuple: A tuple containing a list of database paths and a list of database names.
    """
    database_list = glob.glob(os.path.join(os.getcwd(), '*.sqlite'))
    if not database_list:
        database_names = ['N/A']
    else:
        database_names = [os.path.basename(db) for db in database_list]
    return database_list, database_names

def get_tables_in_database(database_path):
    """
    Get a list of tables in a given SQLite database.

    Parameters:
    - database_path (str): The path to the SQLite database.

    Returns:
    - list: A list of table names in the database.
    """
    conn = sqlite3.connect(database_path)
    table_names = pd.read_sql_query("SELECT name FROM sqlite_master WHERE type='table'", conn)
    conn.close()
    return table_names.values.ravel().tolist()

def main():
    """
    Main function to set up and run the Streamlit web application.
    """
    load_dotenv()
    st.set_page_config(page_title="text2SQL, a SQL-free Life", page_icon=":books:")
    st.write(css, unsafe_allow_html=True)
    st.header(" :chart_with_downwards_trend: Query your Database :chart_with_downwards_trend:")
    user_question = st.chat_input("Ask a query")

    if user_question:
        if re.match(r"^\s*(drop|alter|truncate|delete|insert|update)\s", user_question, re.I):
            st.write(user_template.replace(
                "{{MSG}}", "Sorry, I can't execute queries that can modify the database."), unsafe_allow_html=True)
        else:
            st.write(user_template.replace("{{MSG}}", user_question), unsafe_allow_html=True)

        response = execute_sql_query(user_question)
        if response:
            st.write(bot_template.replace("{{MSG}}", response), unsafe_allow_html=True)


    # Initialize session state variables
    if "dataBase" not in st.session_state:
        st.session_state.dataBase = None
    if "table_names" not in st.session_state:
        st.session_state.table_names = None
    if "table_schemas" not in st.session_state:
        st.session_state.table_schemas = None


    with st.sidebar:
        if st.button("Reset Chat"):
            reset_session_state()

        ###################################### Sidebar_section 1 ########################################################
        st.header("Process new CSVs :file_folder: :file_folder:", divider='rainbow')
        expander = st.expander("Instruction for uploading database.")
        expander.write(Instruction_uploading_database)

        col1, col2 = st.columns(2)
        with col1:
            database_name = st.text_input(
                "Enter Database name",
                placeholder='if Database not exist, we will create'
            )
            st.write(f'Database name : {database_name}')
            st.session_state.dataBase = database_name

        with col2:
            table_names = st.text_input(
                "Enter table names of your choosing",
                placeholder='accept multiple tables: table1, table2..'
            )
            st.write(f'Table names : {table_names}')
            if table_names:
                table_names = table_names.split(',')
            st.session_state.table_names = table_names

        table_schemas = st.text_area(
            "Add the schema of your tables [schema1, schema2...]",
            placeholder="""A single schema should be a dict of {colname: col_dtype}
            example:
                'col1_name': 'dtye',
                'col2_name': 'dtye',
                'col3_name': 'dtye',
                'col4_name': 'dtye'
            ...
            """)

        if table_schemas:
            table_schemas = [i + '}' for i in table_schemas.split("},")[:-1]] + [table_schemas.split("},")[-1]]
            table_schemas = [ast.literal_eval(i) for i in table_schemas]
            st.session_state.table_schemas = table_schemas

        uploaded_files = st.file_uploader(
            "Upload Data files",
            type=list(file_formats.keys()),
            help="Various file formats are supported",
            accept_multiple_files=True
        )

        if uploaded_files:
            data_frames = load_data(uploaded_files)

        if st.button("Process Files"):
            flag = len(data_frames) == len(table_schemas) == len(table_names)
            if flag:
                with st.spinner("Processing"):
                    process_dataframes_to_sql(database_name, table_names, table_schemas, data_frames)
                    st.write('Hurrayy!!!!!, let\'s get started with SQL! :mag: :mag:')
            else:
                reset_session_state()
                st.warning(
                    "The number of schemas, tableNames, and uploaded files are inconsistent. Make sure they have equal lengths and try again."
                )

        ###################################### Sidebar_section 2 ########################################################
        st.subheader("Load pre-existing Database to Query :file_folder: :file_folder:", divider='rainbow')
        expander = st.expander("Instruction for loading a database.")
        expander.write(Instruction_loading_database)

        database_paths, database_names = get_available_databases()
        selected_database = st.selectbox(
            "Select a Database to Connect",
            database_names,
            index=None,
            placeholder="Select a Database...",
        )
        st.write('You selected:', selected_database)

        if st.button("Load Database"):
            reset_session_state()
            if selected_database != 'N/A':
                with st.spinner("Processing"):
                    st.session_state.dataBase = selected_database
                tables_in_database = get_tables_in_database(selected_database)
                table_expander = st.expander("Tables")
                table_expander.write(f"You can query from this list of tables: {tables_in_database}")
                st.write('Hurrayy!!!!!, let\'s get started with SQL! :mag: :mag:')

        ###################################### Sidebar_section 3 ########################################################
        st.subheader('.', divider='rainbow')
        about_app_expander = st.expander("About App")
        about_app_expander.write(App_description)

        st.markdown('''
        The primary resources used to create the app:
                    
        - [Streamlit](https://streamlit.io/)
        - [Langchain](https://docs.langchain.com/docs/)
        - [OpenAI](https://openai.com/)

        ## About Me:

        - [LinkedIn](https://www.linkedin.com/in/pankaj-chouhan/)
        ''')

        to_do_expander = st.expander("To-Do/Warning")
        to_do_expander.write(todo_warning)

if __name__ == '__main__':
    main()
